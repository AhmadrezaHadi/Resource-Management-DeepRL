from enum import Enum
from turtle import back
import numpy as np
import matplotlib.pyplot as plt
from parameters import env_params
from agent import Agent
from backlog import Backlog
# from logger import Logger, LogLevel



class TerminationType(Enum):
    NoNewJob = 1
    AllJobsDone = 2

class Environment():
    """
    Environment of the agent
    """
    def __init__(self, parameters, to_render=False, termination_type=TerminationType.NoNewJob) -> None:
        self.seq_nummber = 0
        self.seq_idx = 0
        self.current_time = 0               # Current time of the machine
        self.current_queue_size = 0     

        self.to_render = False
        self.termination_type = termination_type

        self.job_sequence_length = parameters.job_sequence_length
        self.work_queue_size = parameters.work_queue_size               # size of the work queue
        self.job_queue = np.full(self.work_queue_size, None)            # job queue generated by work_queue_size

        self.agent = Agent(resources_count=parameters['number_resources'],      # our agent
            slots_count=parameters['max_resource_slots'], 
            time_horizon=parameters['time_horizon'])
        self.backlog = Backlog(backlog_size=parameters['backlog_size'])         # backlog of the environment
    
    
    def step(self, action):
        reward = 0
        done = False
        allocation = False

        if action < len(self.job_queue) and self.job_queue[action] is not None:
            allocation = self.agent.schedule_job(job=self.job_queue[action], current_time=self.current_time)
        
        if allocation:
            # remove job from queue
            self.job_queue[action] = None
            self.current_queue_size -= 1
            # fill job queue with backlog
            if not self.backlog.empty():
                self.job_queue[action] = self.backlog.dequeue()
                self.current_queue_size += 1
        else:
            self.current_time += 1
            self.agent.proceed_time(current_time=self.current_time)

            # done = self.done()
            # reward = self.reward()

            if not done:
                # self.fill queue and backlog
                pass
        
        # state = self.return state
        return state, reward, done, allocation 
    
    def reward(self):
        pass
    
    def done(self):
        pass
    
    def render(self):
        pass
